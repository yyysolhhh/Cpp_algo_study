# 투포인터

### 0x00 알고리즘 설명

배열에서 원래 이중 for문으로 O(N^2)에 처리되는 작업을 2개 포인터의 움직임으로 O(N)에 해결하는 알고리즘

이분탐색으로도 해결할 수 있는 문제가 많음

### 0x01 연습 문제 1 - 수 고르기

BOJ 2230번: 수 고르기

```c++
// O(N ^ 2)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (a[j] - a[i] >= m)
            ans = min(ans, a[j] - a[i]);
    }
}
```

1. i가 증가함에 따라 a[j] - a[i]가 m 이상이 되는 최초의 지점 j 또한 증가한다.
2. 각 i에 대해 a[j] - a[i]가 m 이상이 되는 최초의 지점 j를 찾은 이후에는 a[j + 1], a[j + 2], ...을 확인할 필요가 없다.

### 0x02 연습 문제 2 - 부분합

BOJ 1806번: 부분합  
투포인터 - O(N)
누적합에 대한 이분탐색으로도 풀 수 있음 - O(NlgN)
