# Dynamic Programming

### 0x00 알고리즘 설명
- 다이나믹 프로그래밍 (Dynamic Programming, DP)  
여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘  
문제를 해결하기 위한 점화식을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가서 답을 알아내는 형태의 알고리즘

- DP를 푸는 과정
    1. 테이블 정의하기
    2. 점화식 찾기
    3. 초기값 정하기

### 0x01 연습 문제
- BOJ 1463: 1로 만들기
    1. 테이블 정의하기  
        D[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값

    2. 점화식 찾기  
        D[12] = ?  
        3으로 나누거나 (D[12] = D[4] + 1)  
        2으로 나누거나 (D[12] = D[6] + 1)  
        1으로 빼거나 (D[12] = D[11] + 1)  
        D[12] = min(D[4] + 1, D[6] + 1, D[11] + 1)  

        D[k] = ?
        3으로 나누어지면 3으로 나누거나 (D[k] = D[k/3] + 1)  
        2으로 나누어지면 2로 나누거나 (D[k] = D[k/2] + 1)  
        1을 빼거나 (D[k] = D[k-1] + 1),  
        이들 중에서 최솟값
    
    3. 초기값 정의하기  
        D[1] = 0  
        매번 점화식이 돌아갈 수 있게 하기 위한 초기값이 어디까지인지 고민해서 초기값 적용

- BOJ 9095: 1, 2, 3 더하기
    1. 테이블 정의하기  
        D[i] = i를 1, 2, 3의 합으로 나타내는 방법의 수

    2. 점화식 찾기  
        D[4] = ?  
        1+1+1+1, 3+1, 2+1+1, 1+2+1 (3을 1, 2, 3의 합으로 나타내는 방법) + 1, D[3]  
        1+1+2, 2+2 (2를 1, 2, 3의 합으로 나타내는 방법) + 2, D[2]  
        1+3 (1을 1, 2, 3의 합으로 나타내는 방법) + 3, D[1]  
        D[4] = D[1] + D[2] + D[3]  
        D[i] = D[i - 1] + D[i - 2] + D[i - 3]

    3. 초기값 정의하기  
        D[1] = 1, D[2] = 2, D[3] = 4  
        D[i] = D[i - 1] + D[i - 2] + D[i - 3]이니 초기값이 최소 3개는 주어져야 함

- BOJ 2579: 계단 오르기
    1. 테이블 정의하기  
        1) D[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값

        2) D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단은 반드시 밟아야 함
        
        3) D[i] = i번째 계단까지 올라섰을 때 밟지 않을 계단의 합의 최솟값, 단 i번째 계단은 반드시 밟지 않을 계단으로 선택해야 함

    2. 점화식 찾기  
        1) D[1] = 10, D[2] = 20, D[3] = 35, ...

        2) D[k][1] = max(D[k - 1][1], D[k - 2][2]) + S[k]
        D[k][2] = D[k - 1][1] + S[k]

        3) D[k] = min(D[k - 2], D[k - 3]) + S[k]

    3. 초기값 정의하기  
        2) D[1][1] = S[1], D[1][2] = 0,
        D[2][1] = S[2], D[2][2] = S[1] + S[2]

        3) D[1] = S[2], D[2] = S[2], D[3] = S[3]

- BOJ 1149: RGB거리
    1. 테이블 정의하기  
        D[i][0] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번째 집은 빨강
        D[i][1] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번째 집은 초록
        D[i][2] = i번째 집까지 칠할 때 비용의 최솟값, 단 i번째 집은 파랑

    2. 점화식 찾기  
        D[k][0] = min(D[k - 1][1], D[k - 1][2]) + R[k]

    3. 초기값 정의하기  
        D[1][0] = R[1]
        D[1][1] = G[1]
        D[1][2] = B[1]

- BOJ 11726: 2 x n 타일링
    1. 테이블 정의하기  
        D[i] = 2 x i 크기의 직사각형을 채우는 방법의 수 

    2. 점화식 찾기  
        D[n] = D[n - 1] + D[n - 2]

    3. 초기값 정의하기  
        D[1] = 1  
        D[2] = 2
    
    마지막에 나머지 계산을 하면 계산 중간에 int overflow 발생

- BOJ 11659: 구간 합 구하기 4  
    Prefix sum  
    D[i] = A[1] + A[2] + ... + A[i]  
    D[i] = D[i-1] + A[i]

    A[i] + A[i+1] + ... + A[j]  
    = (A[1] + A[2] + ... + A[j]) - (A[1] + A[2] + ... + A[i-1])  
    = D[j] - D[i - 1]  

### 0x02 경로 추적
- BOJ 12852: 1로 만들기 2  
    값 테이블(D)
    | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    | 0 | 1 | 1 | 2 | 3 | 2 | 3 | 3 |

    경로 복원용 테이블(pre)
    | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
    |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
    | 0 | 1 | 1 | 2 | 4 | 3 | 6 | 4 |

    야매 연결리스트 구현할 때 원소 순회하는 상황과 비슷.  
    dp에서 값만 출력하는 것이 아니라 값을 얻은 경로가 필요한 상황이라면 값을 따로 저장한 후 나중에 경로 복원.  
    bfs에서도 경로 복원 가능.
